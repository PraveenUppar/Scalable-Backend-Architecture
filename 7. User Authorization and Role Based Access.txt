• Problem Addressed: Traditional single-token authentication often faced a dilemma: long expiry times (e.g., 30 days) posed a security risk if the token was compromised, allowing attackers prolonged access (e.g., 20 days if stolen after 10 days); while short expiry times (e.g., 1 day) led to poor user experience due to frequent re-logins.
• Solution: Access Tokens & Refresh Tokens: This system offers an ideal approach for large-scale backend applications.
    ◦ Access Token: A short-expiry token (e.g., 15-20 minutes) used for immediate resource access. Its short lifespan limits potential damage if compromised.
    ◦ Refresh Token: A longer-expiry token (e.g., 30 days) used to silently generate new access tokens without requiring the user to re-login, improving user experience. Users only re-login when the refresh token expires.
• Core Implementation:
    ◦ KeyStore Model: A database model (KeyStore) is created to store randomly generated primaryKey (access token key) and secondaryKey (refresh token key) for each user, along with a status. This links tokens to specific users.
    ◦ JWT Functions: JWT is used to encode and encrypt sensitive user information and the token keys before sending them to the client. Functions are implemented for encode, decode, and validate JWTs, incorporating standard JWT payload parameters like issuer, audience, subject (user ID), param (the token key), and validity.
    ◦ Token Storage: Upon login, generated JWTs are stored in HTTP-only cookies on the client-side, not in the response body. This enhances security by preventing client-side JavaScript access (mitigating XSS) and using Secure (HTTPS) and SameSite: Strict (preventing CSRF) flags.
    ◦ Authentication Middleware: A middleware verifies incoming access tokens by decoding, validating their payload against configured values (e.g., issuer, audience, subject), and checking the stored key in the KeyStore.
    ◦ Token Refresh Flow: When an access token expires (e.g., client receives a 401 status code), the client uses the refresh token to request a new access token from a dedicated /refresh endpoint. 
    The server validates the refresh token, invalidates the old token pair, generates a new access token key and refresh token key, stores them, creates new JWTs, and sets them as HTTP-only cookies, effectively refreshing the user's session without a full re-login.